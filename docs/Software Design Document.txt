1. About 
With a little flair of D&D, this is a maze spell, that additionally provides maze section definitions as the parts of a maze and a group of functions to generate complex mazes or its parts.
It is intended for maze designers and enthusiast, for any media, this means that the generated structure can be then used to paint or generate playable mazes.
It quickly provides a base structure of maze or dungeon to play in, by creating the base structure of halls and dead ends, the designer only needs to focus on where to place interesting objectives.
A simple method call can create the full maze or it can be constructed by using more specific functions.
The maze structure is thought to be formed from a collection of halls, where the halls are themselves a collection of spaces or areas that can be connected to other adjacent areas by a door or any kind of passage.
Specific areas would be marked as entrance or exit of the maze in order to define the main path that a traveller must cross to complete it.
The complexity of the maze would be defined by the number of halls and how many branches each hall can have, as well as how long (the number of areas) the halls are. 

2. User Interface 
The current interface includes access to the main maze generator function, with an alternative wizard class to cast the spells as well. In addition there are minor generator functions to manually attempt to generate mazes, which the wizard class can also do.
It should be as simple as importing the module, calling the maze function with the needed parameters, or use the wizard class instance to do the same.

Notes 
You can also provide UI mockups or wireframes here as a part of the user stories to clarify what the flows are going to look like. When I design software, I always must remind myself that I’m doing this for someone else, not for me to pat myself on the back for finding such a nice design. What you design must make sense to the user. Sometimes, that means you need to introduce an extra concept to clarify how your system works. And sometimes the most generic solution is not the best solution for the user.
3. Technical Specification 
• What technical details need developers to know to develop the software or new feature? 
• Are there new tables to add to the database? What fields? 
• How will the software technically work? Are there particular algorithms or libraries that are important?
• What will be the overall design? Which classes are needed? What design patterns are used to model the concepts and relationships? 
• What third-party software is needed to build the software or feature? 
Notes 
You can use UML to draw out the main classes that will be added and how they fit into the rest of the system. When you design your classes and methods, consider design principles such as SOLID. Design principles are the foundation of software design. Going through all of the principles is out of scope for 4 this document, but I have several videos on my YouTube channel where I talk about them, so check those out if you’re not yet comfortable with the principles. On top of the principles are the design patterns, which are standardized solutions to particular software design problems. There are also quite a few videos about those on my channel. This is also a good section to describe specific edge cases that you want the system to handle correctly, for example what should happen in case of a network connection error.
4. Testing and Security 
• Are there specific coverage goals for the unit tests? 
• What kinds of tests are needed (unit, regression, end-to-end, etc)? 
• (new feature only) Are there any potential side-effects on other areas of the application when adding this feature? 
• What security checks need to be in place to allow the software to ship?
• (new feature only) How does the feature impact the security of the software? Is there a need for a security audit before the feature is shipped? 
Notes 
Everybody always talks about how important testing is. One of the main reasons people mention is that it helps you find bugs and produce better, more reliable code. That’s part of it, but there’s a way more important reason to make testing part of how you operate though: by designing and writing code that is easy to test, you develop a tester’s mindset. A mindset that every piece of code potentially breaks something. A mindset that takes edge cases into account by default. If you adopt this mindset, you’ll start to automatically organize your code such that edge cases are handled almost automatically. Design interfaces, classes and methods in such a way that they nudge the users into following the happy flow. 5 For example, suppose you’re writing a function that retrieves users from your database with a particular role. You could use a string argument to specify the name of the role. The problem is that you open the possibility of calling that function with roles that don’t exist. And then you’d have to write extra code to handle that edge case, as well as extra tests to make sure you are actually handling it correctly. Another option is to use an Enum instead. Then, you’re relying on the typing system to handle the edge case for you, saving you a lot of extra work. Write your tests with the assumption that you’re going to change things during your development process: don’t focus too much on reaching 100% test coverage in the beginning but focus on getting a basic version of the feature done so you can evaluate whether this is really what you or your users want. In fact, assume that every line of code you write you’re going to throw away at some point: don’t get attached to the code you write.
5. Deployment 
• Are there any architectural or DevOps changes needed (e.g. adding an extra microservice, changes in deployment pipelines, adding secrets to services)? 
• Are there any migration scripts that need to be written? Notes Especially if you create a tool that runs in the cloud, it’s useful to have some kind of staging environment that closely mimics the production environment. In my company, we have four different environments (this is also called a DTAP street): 
• Develop: this is normally the version of the code running on your local development machine. • Test: this is a version of the application that runs in the cloud, similar to the production environment. 
• Acceptance (also called Staging): version of the application that runs in the cloud, as close as possible to the production environment, often using a copy of the production database. 
• Production: the actual production environment. 
Notes
My team and I use the Develop version on our local machines for actual feature development. The Test version is used to make sure the feature we build works in the cloud (often, things break because of issues with configuration, connection with other services, and so on). The Acceptance version is only used to do final tests before releasing a new version. Here we verify that existing users will still be able to log in and have access to their data.
6. Planning 
• How much time will developing the software or feature cost? 
• What are the steps and how much time does step take? 
• What are the developmental milestones and in what order? 
• What are the main risk factors and are there any alternative routes to take if you find out something isn’t feasible? 
• What parts are absolutely required, and what parts can optionally be done at a later stage? (i.e. the Definition of Done) 
Notes 
Especially if you’re a beginning developer, it’s hard to estimate how much time developing a piece of software takes. You will get better at this after doing it a couple of times. What helps me is first figuring out what the main risk factors are. For example, if you want to add a feature that allows users to integrate your app with Microsoft Teams, the main risk factor is the process of building the actual integration code (which will probably reside partly in the Teams App store), and not the user interface additions in your app to set it up. The more risk factors you have in the software design, the more time you need to reserve for nasty surprises.
7. Broader Context 
• What are limitations of the current design? 
• What are possible extensions to think about for the future? 
• Any other considerations? 
Notes 
Whenever I design software, I always like to include a few “moonshot” ideas: “It would be really cool if the software could also do X”. The reason this is useful is that this puts you in a very open mindset that sometimes leads to new insights. Also, when you’re developing the software, it’s possible that you get an epiphany that allows you to add one of these moonshot ideas. It’s really awesome when that happens!